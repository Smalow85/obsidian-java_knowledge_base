Structural design patterns explain how to assemble objects and classes into larger structures, while keeping these structures flexible and efficient.

- [[Adapter]]: Allows for two incompatible classes to work together by wrapping an interface around one of the existing classes.
- [[Bridge]]: Decouples an abstraction so two classes can vary independently.
- [[Composite]]: Takes a group of objects into a single object.
- [[Decorator]]: Allows for an object’s behavior to be extended dynamically at run time.
- [[Facade]]: Provides a simple interface to a more complex underlying object.
- [[Flyweight]]: Reduces the cost of complex object models.
- [[Proxy]]: Provides a placeholder interface to an underlying object to control access, reduce cost, or reduce complexity.